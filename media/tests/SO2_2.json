{
    "category": "Systemy Operacyjne 2",
    "scope": "Wykład 2: Zarządzanie pamięcią i procesami w jądrze Linux",
    "version": "1.4",
    "questions": [
        {
            "id": 501,
            "questionText": "Jak definiowane jest stronicowanie?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "stronicowanie", "pamięć wirtualna"],
            "options": [
                "Podział pamięci na segmenty o różnym rozmiarze.",
                "Podział pamięci na strony o równym rozmiarze.",
                "Proces przenoszenia całej pamięci fizycznej na dysk.",
                "Metoda alokacji wyłącznie ciągłej pamięci fizycznej."
            ],
            "correctAnswers": [1],
            "explanation": "Stronicowanie to podział pamięci na bloki o stałym rozmiarze, nazywane stronami (w przestrzeni logicznej) i ramkami (w przestrzeni fizycznej)."
        },
        {
            "id": 502,
            "questionText": "Do czego służy funkcja kmalloc() w jądrze Linuxa?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "kmalloc", "sterowniki"],
            "options": [
                "Do przydzielania pamięci, która jest ciągła wirtualnie, ale niekoniecznie ciągła fizycznie.",
                "Do przydzielania obszaru pamięci, który jest gwarantowanie ciągły w fizycznej przestrzeni adresowej.",
                "Do zwalniania pamięci wcześniej zaalokowanej przez vmalloc().",
                "Do tworzenia wirtualnego systemu plików w katalogu /proc."
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja kmalloc() jest używana do alokacji pamięci ciągłej fizycznie. Jest to kluczowe np. dla sterowników urządzeń, które potrzebują ciągłego bufora do operacji DMA (Direct Memory Access)."
        },
        {
            "id": 503,
            "questionText": "Użycie której dyrektywy preprocesora jest wymagane, aby móc skorzystać z funkcji kmalloc()?",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "kmalloc", "nagłówki", "programowanie"],
            "options": [
                "#include <linux/vmalloc.h>",
                "#include <linux/kfifo.h>",
                "#include <linux/slab.h>",
                "#include <linux/module.h>"
            ],
            "correctAnswers": [2],
            "explanation": "Aby używać funkcji kmalloc() i powiązanych z nią funkcji, należy dołączyć plik nagłówkowy <linux/slab.h>."
        },
        {
            "id": 504,
            "questionText": "Ile parametrów i jakiego typu wymaga funkcja kmalloc() do poprawnego wywołania?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "kmalloc", "programowanie"],
            "options": [
                "Jednego: rozmiaru (size_t size).",
                "Dwóch: rozmiaru (size_t size) oraz znacznika typu (gfp_t flags).",
                "Trzech: wskaźnika, rozmiaru i znacznika typu.",
                "Dwóch: wskaźnika do wskaźnika oraz rozmiaru."
            ],
            "correctAnswers": [1],
            "explanation": "Definicja funkcji to 'void *kmalloc(size_t size, gfp_t flags)'. Wymaga ona podania rozmiaru alokowanego bloku pamięci oraz flag określających sposób alokacji (np. GFP_KERNEL)."
        },
        {
            "id": 505,
            "questionText": "Co jest zwracane przez funkcję kmalloc() w przypadku pomyślnego przydziału pamięci?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "kmalloc", "programowanie"],
            "options": [
                "Liczbę całkowitą (int) z kodem sukcesu (0).",
                "Wskaźnik typu void* do początku przydzielonego obszaru pamięci.",
                "Strukturę danych opisującą przydzielony blok.",
                "Nic, funkcja jest typu void."
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja kmalloc() zwraca generyczny wskaźnik (void*) do początku zaalokowanego, ciągłego fizycznie bloku pamięci. W przypadku błędu zwraca NULL."
        },
        {
            "id": 506,
            "questionText": "Jakiej funkcji należy użyć, aby zwolnić pamięć przydzieloną wcześniej za pomocą kmalloc()?",
            "image": "",
            "type": "open-ended",
            "tags": ["pamięć", "jądro", "kfree", "kmalloc", "programowanie"],
            "gradingCriteria": "Odpowiedź musi zawierać nazwę funkcji: kfree().",
            "maxPoints": 2
        },
        {
            "id": 507,
            "questionText": "Czym charakteryzuje się pamięć przydzielona za pomocą funkcji vmalloc()?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "vmalloc", "stronicowanie"],
            "options": [
                "Jest zawsze ciągła w pamięci fizycznej.",
                "Jest dostępna tylko w przestrzeni użytkownika.",
                "Jest ciągła w wirtualnej przestrzeni adresowej jądra, ale może być rozproszona w pamięci fizycznej.",
                "Nie można jej zwolnić po przydzieleniu."
            ],
            "correctAnswers": [2],
            "explanation": "Funkcja vmalloc() przydziela pamięć, która jest ciągła wirtualnie. Mechanizm stronicowania mapuje te wirtualnie ciągłe strony na potencjalnie nieciągłe ramki w pamięci fizycznej."
        },
        {
            "id": 508,
            "questionText": "Aby móc skorzystać z funkcji vmalloc(), należy dołączyć plik nagłówkowy:",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "vmalloc", "nagłówki", "programowanie"],
            "options": [
                "#include <linux/slab.h>",
                "#include <linux/vmalloc.h>",
                "#include <linux/memory.h>",
                "#include <linux/mm.h>"
            ],
            "correctAnswers": [1],
            "explanation": "Prawidłowym plikiem nagłówkowym dla funkcji vmalloc() oraz vfree() jest <linux/vmalloc.h>."
        },
        {
            "id": 509,
            "questionText": "Jakich i ilu parametrów wymaga funkcja vmalloc()?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "vmalloc", "programowanie"],
            "options": [
                "Jednego: rozmiaru w bajtach (unsigned long size).",
                "Dwóch: rozmiaru oraz flag (podobnie jak kmalloc).",
                "Żadnych, rozmiar jest ustalany dynamicznie.",
                "Jednego: wskaźnika, pod który ma być przydzielona pamięć."
            ],
            "correctAnswers": [0],
            "explanation": "Sygnatura funkcji to 'void *vmalloc(unsigned long size)'. Wymaga ona jedynie podania rozmiaru obszaru pamięci, który ma zostać przydzielony."
        },
        {
            "id": 510,
            "questionText": "Co zwraca funkcja vmalloc() po pomyślnej alokacji?",
            "image": "",
            "type": "open-ended",
            "tags": ["pamięć", "jądro", "vmalloc", "programowanie"],
            "gradingCriteria": "Odpowiedź musi wskazywać, że funkcja zwraca wskaźnik do początku przydzielonego wirtualnie ciągłego obszaru pamięci.",
            "maxPoints": 2
        },
        {
            "id": 511,
            "questionText": "Która funkcja służy do zwalniania pamięci przydzielonej za pomocą vmalloc()?",
            "image": "",
            "type": "single-choice",
            "tags": ["pamięć", "jądro", "vfree", "vmalloc"],
            "options": [
                "kfree()",
                "mem_free()",
                "vfree()",
                "delete_vm_area()"
            ],
            "correctAnswers": [2],
            "explanation": "Pamięć zaalokowaną przez vmalloc() należy zwalniać dedykowaną do tego funkcją vfree(), podając jako argument wskaźnik do zwalnianego obszaru."
        },
        {
            "id": 512,
            "questionText": "Jaka struktura danych w jądrze Linuxa, wykorzystująca cyklicznie indeksowaną tablicę, jest często stosowana do komunikacji między procesem producenta a konsumenta?",
            "image": "",
            "type": "single-choice",
            "tags": ["struktury danych", "jądro", "fifo", "kolejka"],
            "options": [
                "Lista dwukierunkowa (list_head)",
                "Drzewo czerwono-czarne",
                "Tablica haszująca",
                "Kolejka FIFO (kfifo)"
            ],
            "correctAnswers": [3],
            "explanation": "Implementacja kolejki FIFO w jądrze Linuxa (kfifo) jest zoptymalizowana pod kątem szybkości i często używana w scenariuszach producent-konsument, np. w sterownikach."
        },
        {
            "id": 513,
            "questionText": "Jaki plik nagłówkowy należy dołączyć, aby korzystać z kernelskiej implementacji kolejki FIFO (kfifo)?",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["struktury danych", "jądro", "fifo", "kolejka", "nagłówki"],
            "options": [
                "#include <linux/list.h>",
                "#include <linux/kfifo.h>",
                "#include <linux/queue.h>",
                "#include <linux/circ_buf.h>"
            ],
            "correctAnswers": [1],
            "explanation": "Wszystkie funkcje i definicje związane z jądrową kolejką FIFO znajdują się w pliku nagłówkowym <linux/kfifo.h>."
        },
        {
            "id": 514,
            "questionText": "Która funkcja służy do inicjalizacji i przydzielenia pamięci dla kolejki FIFO w jądrze?",
            "image": "",
            "type": "single-choice",
            "tags": ["struktury danych", "jądro", "fifo", "kolejka", "programowanie"],
            "options": [
                "kfifo_init()",
                "kfifo_create()",
                "kfifo_alloc()",
                "kfifo_new()"
            ],
            "correctAnswers": [2],
            "explanation": "Funkcja kfifo_alloc() służy do alokacji pamięci o zadanym rozmiarze dla kolejki FIFO oraz do jej inicjalizacji."
        },
        {
            "id": 515,
            "questionText": "Jak zwolnić pamięć zajmowaną przez kolejkę FIFO po zakończeniu jej używania?",
            "image": "",
            "type": "open-ended",
            "tags": ["struktury danych", "jądro", "fifo", "kolejka", "programowanie"],
            "gradingCriteria": "Należy podać nazwę funkcji: kfifo_free(). Jako argument przyjmuje ona wskaźnik do zwalnianej kolejki.",
            "maxPoints": 3
        },
        {
            "id": 516,
            "questionText": "W jaki sposób jądro Linux przechowuje informacje o wszystkich procesach działających w systemie?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "jądro", "task_struct", "lista"],
            "options": [
                "W tablicy statycznej o stałym rozmiarze.",
                "W drzewie binarnym posortowanym według PID.",
                "Na liście dwukierunkowej, której elementami są deskryptory procesów.",
                "W pliku tekstowym w katalogu /proc."
            ],
            "correctAnswers": [2],
            "explanation": "Wszystkie procesy w systemie są połączone w cykliczną listę dwukierunkową. Każdy element tej listy to deskryptor procesu."
        },
        {
            "id": 517,
            "questionText": "Jaka struktura w jądrze Linux zawiera kompletne informacje o pojedynczym procesie (jego PID, stan, otwarte pliki, przestrzeń adresowa etc.)?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "jądro", "task_struct", "struktury danych"],
            "options": [
                "struct process_info",
                "struct pcb",
                "struct task_struct",
                "struct thread_info"
            ],
            "correctAnswers": [2],
            "explanation": "Kluczową strukturą danych opisującą proces w jądrze Linux jest 'struct task_struct'. Zawiera ona wszystkie niezbędne informacje do zarządzania procesem."
        },
        {
            "id": 518,
            "questionText": "Jaki stan opisuje proces, który jest gotowy do wykonania i czeka w kolejce na przydział procesora lub jest aktualnie wykonywany?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "running"],
            "options": [
                "TASK_INTERRUPTIBLE",
                "TASK_RUNNING",
                "TASK_ZOMBIE",
                "TASK_STOPPED"
            ],
            "correctAnswers": [1],
            "explanation": "Stan TASK_RUNNING obejmuje zarówno procesy aktualnie wykonywane przez CPU, jak i te, które są gotowe do wykonania i oczekują w kolejce 'run queue'."
        },
        {
            "id": 519,
            "questionText": "Wskaż, które z poniższych nazw reprezentują rzeczywiste stany procesu w jądrze Linux.",
            "image": "",
            "type": "multiple-choice",
            "tags": ["procesy", "stany", "jądro"],
            "options": [
                "TASK_RUNNING",
                "TASK_WAITING",
                "TASK_STOPPED",
                "TASK_UNINTERRUPTIBLE",
                "TASK_PAUSED",
                "EXIT_DEAD"
            ],
            "correctAnswers": [0, 2, 3, 5],
            "explanation": "TASK_RUNNING, TASK_STOPPED, TASK_UNINTERRUPTIBLE oraz EXIT_DEAD to przykłady faktycznych stanów procesów w Linuksie. Stany takie jak TASK_WAITING czy TASK_PAUSED nie są standardowymi nazwami stanów w kodzie źródłowym jądra."
        },
        {
            "id": 520,
            "questionText": "Proces znajduje się w stanie, w którym jest uśpiony i czeka na zasób (np. na odblokowanie semafora), ale nie reaguje na żadne sygnały. Jak nazywa się ten stan?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "uninterruptible"],
            "options": [
                "TASK_INTERRUPTIBLE",
                "TASK_ZOMBIE",
                "TASK_UNINTERRUPTIBLE",
                "TASK_STOPPED"
            ],
            "correctAnswers": [2],
            "explanation": "Stan TASK_UNINTERRUPTIBLE (nieprzerywalny sen) jest używany w sytuacjach, gdy proces musi czekać na zakończenie operacji bez możliwości przerwania, np. podczas krytycznych operacji wejścia-wyjścia. Proces w tym stanie nie może zostać 'zabity' sygnałem."
        },
        {
            "id": 521,
            "questionText": "Co się dzieje, gdy proces przechodzi w stan TASK_STOPPED?",
            "image": "",
            "type": "open-ended",
            "tags": ["procesy", "stany", "jądro", "stopped"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że proces w stanie TASK_STOPPED zatrzymał swoje wykonywanie, najczęściej w odpowiedzi na otrzymany sygnał (np. SIGSTOP, SIGTSTP). Proces w tym stanie nie jest brany pod uwagę przez scheduler, dopóki nie otrzyma sygnału SIGCONT, który wznowi jego działanie. Pełna punktacja za wskazanie przyczyny (sygnał) i skutku (zatrzymanie wykonania).",
            "maxPoints": 5
        },
        {
            "id": 522,
            "questionText": "Jak nazywa się stan, w którym proces został zatrzymany na potrzeby debugowania przez inny proces (debugger)?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "traced", "debugowanie"],
            "options": [
                "TASK_DEBUG",
                "TASK_STOPPED",
                "TASK_ZOMBIE",
                "TASK_TRACED"
            ],
            "correctAnswers": [3],
            "explanation": "Stan TASK_TRACED oznacza, że wykonanie procesu jest monitorowane i kontrolowane przez inny proces, np. debugger (jak gdb), który używa mechanizmu ptrace."
        },
        {
            "id": 523,
            "questionText": "Jakich funkcji używa się w kodzie jądra do jawnej zmiany stanu bieżącego procesu?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["procesy", "stany", "jądro", "programowanie"],
            "options": [
                "change_state()",
                "set_task_state()",
                "alter_process()",
                "set_current_state()"
            ],
            "correctAnswers": [1, 3],
            "explanation": "W kodzie modułów jądra do zmiany stanu procesu używa się funkcji set_task_state() (dla dowolnego procesu) oraz set_current_state() (dla bieżącego procesu). Ustawiają one odpowiednią wartość w polu 'state' struktury task_struct."
        },
        {
            "id": 524,
            "questionText": "Proces jest uśpiony i czeka na konkretne zdarzenie, ale może zostać przerwany przez sygnał. Jaki to stan?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "interruptible"],
            "options": [
                "TASK_UNINTERRUPTIBLE",
                "TASK_ZOMBIE",
                "TASK_INTERRUPTIBLE",
                "TASK_TRACED"
            ],
            "correctAnswers": [2],
            "explanation": "TASK_INTERRUPTIBLE to stan uśpienia, z którego proces może zostać wybudzony przez nadejście oczekiwanego zdarzenia lub przez sygnał."
        },
        {
            "id": 525,
            "questionText": "Jak nazywa się stan, w którym proces zakończył działanie, ale jego deskryptor wciąż jest utrzymywany w systemie, aby proces nadrzędny mógł odczytać jego status zakończenia?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "zombie"],
            "options": [
                "EXIT_DEAD",
                "TASK_STOPPED",
                "TASK_ZOMBIE",
                "TASK_KILLED"
            ],
            "correctAnswers": [2],
            "explanation": "Proces zombie (TASK_ZOMBIE) to proces, który zakończył wykonanie, ale jego wpis w tablicy procesów wciąż istnieje do momentu, aż proces-rodzic go 'odbierze' za pomocą wywołania wait()."
        },
        {
            "id": 526,
            "questionText": "Jaka jest kluczowa różnica między funkcjami `set_task_state()` a `set_current_state()`?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "programowanie"],
            "options": [
                "Nie ma różnicy, są to aliasy tej samej funkcji.",
                "`set_task_state()` ustawia stan dla dowolnego procesu podanego jako argument, a `set_current_state()` tylko dla procesu bieżącego.",
                "`set_current_state()` jest starszą, przestarzałą wersją `set_task_state()`.",
                "`set_task_state()` jest używana tylko dla stanów uśpienia, a `set_current_state()` dla stanów aktywnych."
            ],
            "correctAnswers": [1],
            "explanation": "`set_current_state()` to zoptymalizowane makro do zmiany stanu bieżącego procesu (działające na wskaźniku 'current'), podczas gdy `set_task_state()` jest bardziej ogólną funkcją przyjmującą wskaźnik do dowolnej struktury task_struct."
        },
        {
            "id": 527,
            "questionText": "Która funkcja służy do dodania elementu do kolejki FIFO, a która do jego pobrania (i usunięcia)?",
            "image": "",
            "type": "single-choice",
            "tags": ["struktury danych", "jądro", "fifo", "kolejka"],
            "options": [
                "Dodawanie: kfifo_put(), Pobieranie: kfifo_get()",
                "Dodawanie: kfifo_in(), Pobieranie: kfifo_out()",
                "Dodawanie: kfifo_add(), Pobieranie: kfifo_remove()",
                "Dodawanie: kfifo_push(), Pobieranie: kfifo_pop()"
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja kfifo_in() służy do dodawania elementu do kolejki, a kfifo_out() do jego pobrania, co oznacza jednoczesne odczytanie i usunięcie elementu."
        },
        {
            "id": 528,
            "questionText": "Czym jest stan TASK_KILLABLE i dla którego innego stanu stanowi on nowszą alternatywę?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "stany", "jądro", "killable"],
            "options": [
                "Jest to alternatywa dla TASK_RUNNING, proces można zakończyć, gdy jest gotowy.",
                "Jest to alternatywa dla TASK_ZOMBIE, pozwala na natychmiastowe usunięcie procesu.",
                "Jest to alternatywa dla TASK_UNINTERRUPTIBLE, proces jest uśpiony, ale reaguje na sygnały zakończenia.",
                "Jest to alternatywa dla TASK_STOPPED, proces jest zatrzymany i może być zakończony."
            ],
            "correctAnswers": [2],
            "explanation": "TASK_KILLABLE to stan uśpienia podobny do TASK_UNINTERRUPTIBLE, ale z kluczową różnicą: proces w tym stanie może zostać przerwany i zakończony przez sygnał 'kill'. Stanowi to bezpieczniejszą alternatywę dla długotrwałego, nieprzerywalnego snu."
        },
        {
            "id": 529,
            "questionText": "Do czego w kodzie jądra odnosi się makro 'current'?",
            "image": "",
            "type": "single-choice",
            "tags": ["procesy", "jądro", "current", "programowanie"],
            "options": [
                "Do wskaźnika na strukturę task_struct aktualnie wykonywanego procesu.",
                "Do identyfikatora (PID) aktualnie wykonywanego procesu.",
                "Do nazwy modułu, który jest obecnie ładowany.",
                "Do wskaźnika na początek pamięci jądra."
            ],
            "correctAnswers": [0],
            "explanation": "Makro 'current' jest szeroko stosowanym w kodzie jądra skrótem, który zwraca wskaźnik do deskryptora procesu (struct task_struct) tego zadania, które jest aktualnie wykonywane na danym procesorze."
        },
        {
            "id": 530,
            "questionText": "Czym jest wirtualny system plików procfs?",
            "image": "",
            "type": "single-choice",
            "tags": ["procfs", "sysfs", "jądro", "system plików"],
            "options": [
                "Systemem plików służącym do trwałego przechowywania konfiguracji jądra.",
                "Mechanizmem umożliwiającym dwustronną komunikację z modułami i procesami jądra w trakcie ich wykonywania.",
                "Zestawem sterowników do obsługi fizycznych nośników danych.",
                "Systemem plików przechowującym wyłącznie informacje o urządzeniach w systemie."
            ],
            "correctAnswers": [1],
            "explanation": "Procfs to wirtualny system plików, który dostarcza mechanizmu do komunikacji z jądrem. Pozwala nie tylko odczytywać informacje (np. o procesach), ale także przekazywać dane do jądra."
        },
        {
            "id": 531,
            "questionText": "Jaki jest główny cel wirtualnego systemu plików sysfs?",
            "image": "",
            "type": "single-choice",
            "tags": ["procfs", "sysfs", "jądro", "system plików"],
            "options": [
                "Dostarczanie informacji o procesach, podobnie jak procfs.",
                "Eksportowanie do przestrzeni użytkownika informacji o urządzeniach i sterownikach z modelu urządzeń jądra.",
                "Przechowywanie plików logów generowanych przez jądro i moduły.",
                "Zarządzanie licencjami oprogramowania w systemie."
            ],
            "correctAnswers": [1],
            "explanation": "Sysfs jest nowocześniejszym uzupełnieniem procfs, które służy głównie do prezentowania informacji o urządzeniach, sterownikach i magistralach systemowych w ustrukturyzowany sposób."
        },
        {
            "id": 532,
            "questionText": "Do czego pierwotnie służył wirtualny system plików w katalogu /proc?",
            "image": "",
            "type": "single-choice",
            "tags": ["procfs", "jądro", "procesy"],
            "options": [
                "Do konfiguracji sieci.",
                "Do pobierania informacji o procesach w systemie.",
                "Do kompilacji modułów jądra.",
                "Do zarządzania pamięcią wirtualną."
            ],
            "correctAnswers": [1],
            "explanation": "Jak wskazuje nazwa (proc -> process), system plików /proc został pierwotnie stworzony, aby w prosty sposób udostępniać informacje o uruchomionych procesach."
        },
        {
            "id": 533,
            "questionText": "Która z podanych funkcji służy do utworzenia nowego pliku w wirtualnym systemie plików /proc?",
            "image": "",
            "type": "single-choice",
            "tags": ["procfs", "jądro", "programowanie"],
            "options": [
                "create_proc_file()",
                "proc_register()",
                "new_proc_entry()",
                "proc_create_data()"
            ],
            "correctAnswers": [3],
            "explanation": "Funkcja proc_create_data() jest używana do tworzenia plików w katalogu /proc i powiązania ich z odpowiednimi operacjami odczytu/zapisu."
        },
        {
            "id": 534,
            "questionText": "Jaki plik nagłówkowy jest niezbędny, aby móc tworzyć i zarządzać plikami w systemie /proc z poziomu modułu jądra?",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["procfs", "jądro", "programowanie", "nagłówki"],
            "options": [
                "#include <linux/fs.h>",
                "#include <linux/proc_fs.h>",
                "#include <linux/sysfs.h>",
                "#include <linux/virtual.h>"
            ],
            "correctAnswers": [1],
            "explanation": "Aby korzystać z funkcji takich jak proc_create_data(), należy dołączyć plik nagłówkowy <linux/proc_fs.h>."
        },
        {
            "id": 535,
            "questionText": "Wskaż polecenia, których można użyć do odczytania zawartości pliku w /proc/sys, np. /proc/sys/net/ipv4/ip_forward.",
            "image": "",
            "type": "multiple-choice",
            "tags": ["procfs", "polecenia", "cat", "sysctl"],
            "options": [
                "cat",
                "read",
                "sysctl",
                "proc_read"
            ],
            "correctAnswers": [0, 2],
            "explanation": "Dostępne metody odczytu to: użycie edytora (np. nano), polecenia `cat` oraz polecenia `sysctl`."
        },
        {
            "id": 536,
            "questionText": "Opisz, jaką rolę pełni struktura file_operations w kontekście tworzenia plików w systemie procfs.",
            "image": "",
            "type": "open-ended",
            "tags": ["procfs", "jądro", "programowanie", "file_operations"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że struktura `file_operations` zawiera wskaźniki do funkcji, które jądro ma wywołać, gdy użytkownik wykonuje standardowe operacje na pliku (takie jak odczyt, zapis, otwarcie). Przekazanie wskaźnika do tej struktury w funkcji `proc_create_data` pozwala zdefiniować, co ma się stać, gdy ktoś próbuje czytać z naszego pliku w /proc lub do niego pisać. Pełna punktacja za poprawne zidentyfikowanie roli (powiązanie operacji z funkcjami) i kontekstu użycia.",
            "maxPoints": 8
        }
    ]
}
