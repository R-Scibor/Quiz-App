{
    "category": "Systemy Operacyjne 2",
    "scope": "Wykład 1: Jądro systemu Linux i moduły",
    "version": "1.3",
    "questions": [
        {
            "id": 408,
            "questionText": "Patrząc na załączony diagram architektury systemu Linux, przyporządkuj nazwy warstw z poniższej listy do odpowiednich numerów (od 1 do 5) na schemacie.\n\nLista warstw:\nA. Biblioteka standardowa (open, close, read, write, fork itp.)\nB. Sprzęt (procesor, pamięć, dyski, terminale itp.)\nC. Użytkownicy\nD. Standardowe programy użytkowe (powłoka, edytory, kompilatory, itp.)\nE. System operacyjny Linux (zarządzanie procesami, zarządzanie pamięcią, system plików, wejście-wyjscie itp.)",
            "image": "/static/budowalinux.png",
            "type": "open-ended",
            "tags": ["linux", "architektura", "jądro", "warstwy", "dopasowanie"],
            "gradingCriteria": "Odpowiedź musi zawierać poprawne przyporządkowanie wszystkich pięciu warstw do numerów na diagramie. Poprawna kolejność od góry do dołu (od 1 do 5) to: 1-C (Użytkownicy), 2-D (Standardowe programy użytkowe), 3-A (Biblioteka standardowa), 4-E (System operacyjny Linux), 5-B (Sprzęt). Przyznaj 2 punkty za każdą poprawnie przypisaną parę.",
            "maxPoints": 10
        },
        {
            "id": 409,
            "questionText": "Opisz krótko dwa podstawowe rodzaje jąder systemów operacyjnych: monolityczne i mikrojądro, wymieniając ich kluczowe cechy (zalety i wady).",
            "image": "",
            "type": "open-ended",
            "tags": ["jądro", "monolityczne", "mikrojądro", "architektura"],
            "gradingCriteria": "Odpowiedź musi zawierać: 1. Definicję jądra monolitycznego (jeden duży proces, jedna przestrzeń adresowa, wysoka wydajność, niska niezawodność). 2. Definicję mikrojądra (podział na serwery/usługi, komunikacja międzyprocesowa, niższa wydajność, wysoka niezawodność, skomplikowana budowa). Przyznaj do 4 punktów za poprawny opis jądra monolitycznego, do 4 punktów za poprawny opis mikrojądra i 2 punkty za trafne porównanie wydajności i niezawodności.",
            "maxPoints": 10
        },
        {
            "id": 410,
            "questionText": "Jakiego typu jądrem, zgodnie z prezentacją, jest jądro systemu Linux?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "jądro", "monolityczne", "moduły"],
            "options": [
                "Mikrojądro",
                "Jądro monolityczne",
                "Jądro hybrydowe",
                "Jądro egzotyczne"
            ],
            "correctAnswers": [1],
            "explanation": "Jądro Linux jest monolityczne, ale jego funkcjonalność można rozszerzać za pomocą dynamicznie ładowalnych modułów, co daje mu pewną elastyczność."
        },
        {
            "id": 411,
            "questionText": "Która z wymienionych cech jest kluczową różnicą pomiędzy jądrem Linux a klasycznym jądrem Unix?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "unix", "jądro", "smp"],
            "options": [
                "Jądro Linux jest w pełni mikrojądrem, a Unix monolitem.",
                "Linux natywnie obsługuje symetryczną wieloprocesorowość (SMP), czego brakowało w oryginalnym Unixie.",
                "Linux nie pozwala na dynamiczne ładowanie modułów, w przeciwieństwie do Unixa.",
                "Linux jest systemem zamkniętym, a Unix otwartym oprogramowaniem."
            ],
            "correctAnswers": [1],
            "explanation": "Wsparcie dla SMP było jedną z istotnych przewag i cech rozwojowych jądra Linux w porównaniu do klasycznych implementacji Unixa."
        },
        {
            "id": 412,
            "questionText": "Co oznacza, że jądro Linuxa pracuje w trybie z wywłaszczaniem (preemptive)?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "jądro", "wywłaszczanie", "preemption"],
            "options": [
                "Proces może działać tak długo, jak chce, bez przerwy.",
                "System operacyjny może przerwać działający proces, aby przydzielić czas procesora innemu, ważniejszemu zadaniu.",
                "Wszystkie procesy mają dokładnie taki sam, niezmienny priorytet.",
                "Procesy są wykonywane tylko w trybie użytkownika."
            ],
            "correctAnswers": [1],
            "explanation": "Praca z wywłaszczaniem (preemptive multitasking) pozwala systemowi na lepsze zarządzanie czasem procesora i zapobiega sytuacji, w której jeden proces blokuje cały system. Klasyczny Unix pracował bez wywłaszczania."
        },
        {
            "id": 413,
            "questionText": "Wskaż fundamentalną różnicę dotyczącą modelu jądra między Linuxem a klasycznym Unixem, opisaną w prezentacji.",
            "image": "",
            "type": "multiple-choice",
            "tags": ["linux", "unix", "jądro", "moduły"],
            "options": [
                "Linux ma jądro monolityczne z możliwością dynamicznego ładowania modułów.",
                "Klasyczny Unix miał jądro ściśle monolityczne, bez obsługi modułów.",
                "Linux w pełni implementuje wszystkie opcje z klasycznego Unixa.",
                "Linux jest oprogramowaniem otwartym, w przeciwieństwie do wielu zamkniętych gałęzi Unixa."
            ],
            "correctAnswers": [0, 1, 3],
            "explanation": "Główna różnica w architekturze to monolityczność z modułami w Linuksie. Dodatkowo, model licencjonowania (open source) jest kluczową cechą odróżniającą go od komercyjnych Unixów. Linux celowo nie implementuje niektórych historycznych opcji Unixa."
        },
        {
            "id": 414,
            "questionText": "Jaka jest minimalna dyrektywa preprocesora, która musi być zawarta w kodzie źródłowym modułu jądra Linux?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "moduł jądra", "programowanie", "nagłówki"],
            "options": [
                "#include <linux/kernel.h>",
                "#include <linux/init.h>",
                "#include <linux/module.h>",
                "#include <stdio.h>"
            ],
            "correctAnswers": [2],
            "explanation": "Plik nagłówkowy <linux/module.h> zawiera podstawowe definicje i makra niezbędne do stworzenia każdego modułu jądra."
        },
        {
            "id": 415,
            "questionText": "Które makra służą do zarejestrowania funkcji inicjalizującej i kończącej pracę modułu jądra?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["linux", "moduł jądra", "programowanie", "init", "exit"],
            "options": [
                "module_init()",
                "module_exit()",
                "MODULE_LICENSE()",
                "MODULE_AUTHOR()"
            ],
            "correctAnswers": [0, 1],
            "explanation": "Makro 'module_init()' wskazuje, która funkcja ma być wywołana podczas ładowania modułu, a 'module_exit()' definiuje funkcję czyszczącą, wywoływaną przy jego usuwaniu."
        },
        {
            "id": 416,
            "questionText": "Które polecenie służy do załadowania skompilowanego modułu jądra (np. o nazwie 'modulik.ko') do systemu?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "polecenia", "moduł jądra", "insmod"],
            "options": [
                "loadmod modulik.ko",
                "rmmod modulik.ko",
                "lsmod modulik.ko",
                "insmod modulik.ko"
            ],
            "correctAnswers": [3],
            "explanation": "Polecenie 'insmod' (insert module) służy do wstawienia/załadowania modułu do działającego jądra."
        },
        {
            "id": 417,
            "questionText": "Jakiego polecenia użyjesz, aby wyświetlić listę wszystkich aktualnie załadowanych modułów w jądrze Linux?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "polecenia", "moduł jądra", "lsmod"],
            "options": [
                "insmod",
                "dmesg",
                "lsmod",
                "rmmod"
            ],
            "correctAnswers": [2],
            "explanation": "Polecenie 'lsmod' (list modules) pokazuje listę załadowanych modułów, ich rozmiar oraz moduły, od których są zależne."
        },
        {
            "id": 418,
            "questionText": "Chcesz zobaczyć ostatnie komunikaty wygenerowane przez jądro, w tym te z właśnie załadowanego modułu. Którego polecenia (z opcjonalnym potokiem) użyjesz, aby wyświetlić tylko 10 ostatnich linii?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "polecenia", "dmesg", "debugowanie"],
            "options": [
                "lsmod | tail",
                "dmesg | head",
                "dmesg | tail",
                "printk | tail"
            ],
            "correctAnswers": [2],
            "explanation": "Polecenie 'dmesg' odczytuje bufor komunikatów jądra. Użycie potoku '|' i polecenia 'tail' pozwala na przefiltrowanie wyniku i pokazanie tylko ostatnich linii, co jest bardzo przydatne przy debugowaniu modułów."
        },
        {
            "id": 419,
            "questionText": "Jak wygląda przykładowe wywołanie modułu o nazwie `modulik.ko`, które przekazuje do niego parametr `tablica` z wartościami 5, 6 i 9?",
            "image": "",
            "type": "single-choice",
            "tags": ["linux", "moduł jądra", "parametry", "insmod"],
            "options": [
                "insmod modulik.ko --tablica=5,6,9",
                "insmod modulik.ko tablica=5,6,9",
                "insmod modulik.ko 5 6 9",
                "insmod modulik.ko set tablica [5,6,9]"
            ],
            "correctAnswers": [1],
            "explanation": "Parametry do modułu jądra przekazuje się podczas jego ładowania poleceniem 'insmod' w formacie 'nazwa_parametru=wartość'. W przypadku tablic, wartości oddziela się przecinkami."
        },
        {
            "id": 420,
            "questionText": "Jaka jest rola funkcji `printk()` w module jądra i czym fundamentalnie różni się od `printf()` z biblioteki standardowej C?",
            "image": "",
            "type": "open-ended",
            "tags": ["linux", "moduł jądra", "programowanie", "printk", "debugowanie"],
            "gradingCriteria": "Odpowiedź musi zawierać: 1. Cel printk(): wypisywanie komunikatów z kodu działającego w przestrzeni jądra. 2. Miejsce docelowe: bufor komunikatów jądra (dostępny przez dmesg). 3. Kluczowe ograniczenie: brak obsługi liczb zmiennoprzecinkowych. 4. Możliwość określenia poziomu ważności komunikatu (np. KERN_INFO, KERN_ALERT). Pełna punktacja za wskazanie wszystkich czterech elementów.",
            "maxPoints": 10
        }
    ]
}
