{
    "category": "Systemy Operacyjne 2",
    "scope": "Wykład 4: Przerwania i sygnały w jądrze Linux",
    "version": "1.1",
    "questions": [
        {
            "id": 701,
            "questionText": "Czym jest przerwanie w kontekście systemu operacyjnego?",
            "image": "",
            "type": "open-ended",
            "tags": ["przerwania", "sygnały", "jądro"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że przerwanie to mechanizm, który powoduje wstrzymanie normalnego wykonywania programu i skok do specjalnej procedury obsługi. Musi być zawarty podział na przerwania sprzętowe (generowane przez urządzenia zewnętrzne, np. zegar, karta sieciowa) i programowe (generowane przez instrukcje w kodzie, np. wywołania systemowe, sygnały). Pełna punktacja za definicję i podział.",
            "maxPoints": 6
        },
        {
            "id": 702,
            "questionText": "Jaka jest ogólna zasada dotycząca numeracji i priorytetu przerwań?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "priorytet"],
            "options": [
                "Przerwania programowe mają niższe numery i wyższy priorytet.",
                "Przerwania sprzętowe mają niższe numery i wyższy priorytet.",
                "Wszystkie przerwania mają takie same numery i priorytety.",
                "Przerwania sprzętowe mają wyższe numery i niższy priorytet."
            ],
            "correctAnswers": [1],
            "explanation": "Zazwyczaj przerwania generowane przez sprzęt, jako bardziej krytyczne, mają niższe numery i są obsługiwane z wyższym priorytetem niż przerwania programowe."
        },
        {
            "id": 703,
            "questionText": "Które z poniższych są przykładami przerwań sprzętowych?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["przerwania", "sprzętowe"],
            "options": [
                "Przerwanie zegarowe.",
                "Wysłanie sygnału SIGKILL do procesu.",
                "Informacja o zakończeniu operacji wejścia/wyjścia przez dysk twardy.",
                "Wywołanie instrukcji INT 0x80."
            ],
            "correctAnswers": [0, 2],
            "explanation": "Przerwania sprzętowe są generowane przez urządzenia zewnętrzne. Przerwanie zegarowe i informacja od kontrolera dysku są klasycznymi przykładami. Sygnały i instrukcje INT są przerwaniami programowymi."
        },
        {
            "id": 704,
            "questionText": "Które z poniższych są przykładami przerwań programowych?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["przerwania", "programowe", "sygnały"],
            "options": [
                "Naciśnięcie kombinacji klawiszy Ctrl-C w terminalu.",
                "Wywołanie funkcji systemowej przez program.",
                "Odebranie pakietu przez kartę sieciową.",
                "Próba odwołania się do nieprawidłowego adresu w pamięci przez proces."
            ],
            "correctAnswers": [0, 1, 3],
            "explanation": "Przerwania programowe są inicjowane w wyniku działania programu lub zdarzeń z nim związanych. Obejmują one sygnały (np. od terminala), jawne wywołania systemowe oraz błędy wykonania (wyjątki procesora)."
        },
        {
            "id": 705,
            "questionText": "W jaki sposób sygnały wpisują się w koncepcję przerwań?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sygnały"],
            "options": [
                "Są to przerwania sprzętowe o najwyższym priorytecie.",
                "Są to asynchroniczne przerwania programowe, służące do komunikacji z procesami na poziomie użytkownika.",
                "Są to synchroniczne przerwania sprzętowe, generowane przez CPU.",
                "Nie mają żadnego związku z przerwaniami."
            ],
            "correctAnswers": [1],
            "explanation": "Sygnały są formą przerwania programowego, które informuje proces o wystąpieniu pewnego zdarzenia. Działają asynchronicznie, co oznacza, że mogą przerwać normalne działanie procesu w dowolnym momencie."
        },
        {
            "id": 706,
            "questionText": "Czym jest sygnał w systemie Linux?",
            "image": "",
            "type": "open-ended",
            "tags": ["przerwania", "sygnały", "procesy"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że sygnał to komunikat wysyłany do procesu przez jądro, inny proces lub użytkownika w celu poinformowania go o wystąpieniu zdarzenia. Przykłady zdarzeń to błąd programu, zakończenie operacji I/O, czy żądanie zakończenia pracy. Pełna punktacja za definicję i podanie co najmniej jednego źródła sygnału.",
            "maxPoints": 5
        },
        {
            "id": 707,
            "questionText": "Jak reprezentowany jest identyfikator sygnału?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "reprezentacja"],
            "options": [
                "Jako liczba całkowita od 1 do 64.",
                "Jako struktura zawierająca nazwę i numer.",
                "Jako sześcioliterowy identyfikator ze stałym prefiksem 'SIG'.",
                "Jako ścieżka do pliku w systemie /dev."
            ],
            "correctAnswers": [2],
            "explanation": "Nazwy sygnałów w kodzie źródłowym i dokumentacji mają postać identyfikatora składającego się ze stałej części 'SIG' i części zmiennej, np. SIGKILL, SIGINT, SIGSTOP."
        },
        {
            "id": 708,
            "questionText": "Które z poniższych sygnałów służą do zatrzymania i wznowienia procesu?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["sygnały", "procesy"],
            "options": [
                "SIGKILL",
                "SIGSTOP",
                "SIGCONT",
                "SIGQUIT"
            ],
            "correctAnswers": [1, 2],
            "explanation": "SIGSTOP (i podobny SIGTSTP) służy do zatrzymania (wstrzymania) procesu, a SIGCONT służy do wznowienia jego działania."
        },
        {
            "id": 709,
            "questionText": "Jaka jest ogólna rola struktury `sigaction`?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie"],
            "options": [
                "Służy do przechowywania listy wszystkich wysłanych sygnałów w systemie.",
                "Służy do zdefiniowania, w jaki sposób proces ma zareagować na konkretny sygnał.",
                "Służy do tworzenia nowych, niestandardowych sygnałów.",
                "Służy do blokowania wszystkich przerwań sprzętowych."
            ],
            "correctAnswers": [1],
            "explanation": "Struktura `sigaction` pozwala w szczegółowy sposób określić akcję do podjęcia po otrzymaniu sygnału, zdefiniować maskę sygnałów do zablokowania oraz ustawić dodatkowe flagi modyfikujące zachowanie."
        },
        {
            "id": 710,
            "questionText": "Co określa pole `sa_handler` w strukturze `sigaction`?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie"],
            "options": [
                "Maskę sygnałów, które mają być blokowane podczas obsługi.",
                "Wskaźnik do funkcji, która ma zostać wywołana w odpowiedzi na sygnał (uchwyt sygnału).",
                "Znaczniki modyfikujące sposób obsługi sygnału.",
                "Wskaźnik do funkcji przywracającej, która nie jest obecnie używana."
            ],
            "correctAnswers": [1],
            "explanation": "Pole `sa_handler` jest kluczowe, ponieważ to w nim umieszcza się wskaźnik do własnej funkcji obsługi sygnału lub predefiniowane wartości takie jak SIG_DFL (domyślnie) lub SIG_IGN (ignoruj)."
        },
        {
            "id": 711,
            "questionText": "Jaka jest rola pola `sa_mask` w strukturze `sigaction`?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie"],
            "options": [
                "Określa, który sygnał ma być obsłużony.",
                "Definiuje zestaw sygnałów, które będą tymczasowo blokowane na czas wykonywania procedury obsługi sygnału.",
                "Wskazuje na domyślną procedurę obsługi.",
                "Ustawia flagi, takie jak SA_RESTART."
            ],
            "correctAnswers": [1],
            "explanation": "Dzięki `sa_mask` można zapobiec przerwaniu procedury obsługi jednego sygnału przez inny, określony sygnał, co zapobiega powstawaniu tzw. 'race conditions'."
        },
        {
            "id": 712,
            "questionText": "Co oznacza flaga `SA_RESTART` ustawiona w polu `sa_flags` struktury `sigaction`?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie"],
            "options": [
                "Powoduje, że po obsłudze sygnału proces jest restartowany od początku.",
                "Powoduje, że obsługa sygnału jest jednorazowa i po niej przywracana jest obsługa domyślna.",
                "Powoduje, że przerwane przez sygnał wywołanie systemowe jest automatycznie wznawiane po zakończeniu obsługi sygnału.",
                "Powoduje, że sygnał jest ignorowany."
            ],
            "correctAnswers": [2],
            "explanation": "Flaga `SA_RESTART` jest bardzo użyteczna, ponieważ zapobiega błędom (np. `EINTR`) w wolnych wywołaniach systemowych (np. `read`), które zostały przerwane przez nadejście sygnału."
        },
        {
            "id": 713,
            "questionText": "Do czego służy pole `sa_restorer` w strukturze `sigaction`?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie"],
            "options": [
                "Do przywracania domyślnej obsługi sygnału.",
                "Jest to pole historyczne, obecnie nieużywane w standardzie POSIX.",
                "Do przywracania poprzedniej maski sygnałów.",
                "Do restartowania procesu po obsłudze sygnału."
            ],
            "correctAnswers": [1],
            "explanation": "Pole `sa_restorer` było używane w starszych systemach, ale w nowoczesnych implementacjach zgodnych z POSIX nie jest używane i nie należy go modyfikować."
        },
        {
            "id": 714,
            "questionText": "Jaki plik nagłówkowy jest wymagany, aby używać struktury `sigaction` i powiązanych z nią funkcji?",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "programowanie", "nagłówki"],
            "options": [
                "<stdio.h>",
                "<unistd.h>",
                "<signal.h>",
                "<sys/interrupt.h>"
            ],
            "correctAnswers": [2],
            "explanation": "Wszystkie definicje typów, struktur (jak `sigaction`) i funkcji (jak `sigaction()`, `kill()`) związanych z obsługą sygnałów znajdują się w pliku nagłówkowym `<signal.h>`."
        },
        {
            "id": 715,
            "questionText": "Jak w systemie Linux realizowane jest klasyczne wywołanie funkcji systemowej?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "programowe", "systemowe"],
            "options": [
                "Poprzez wysłanie sygnału SIGSYS do jądra.",
                "Poprzez specjalną instrukcję procesora (np. INT 0x80 lub SYSCALL), która generuje przerwanie programowe.",
                "Poprzez bezpośrednie wywołanie funkcji jądra z kodu użytkownika.",
                "Poprzez zapisanie żądania do pliku w systemie /proc."
            ],
            "correctAnswers": [1],
            "explanation": "Program użytkownika umieszcza numer funkcji systemowej i jej argumenty w odpowiednich rejestrach, a następnie wykonuje instrukcję generującą przerwanie, przekazując sterowanie do jądra w trybie uprzywilejowanym."
        },
        {
            "id": 716,
            "questionText": "Czym jest APIC (Advanced Programmable Interrupt Controller)?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "apic"],
            "options": [
                "Układem w procesorze odpowiedzialnym za wykonywanie operacji arytmetycznych.",
                "Rozproszonym układem w chipsecie i procesorze, odpowiedzialnym za zarządzanie i dystrybucję przerwań sprzętowych w systemie.",
                "Interfejsem programowym do wysyłania sygnałów między procesami.",
                "Specjalnym typem pamięci podręcznej dla przerwań."
            ],
            "correctAnswers": [1],
            "explanation": "APIC to zaawansowany kontroler przerwań, który zastąpił starszy PIC. Jest kluczowy dla obsługi przerwań w systemach wieloprocesorowych, umożliwiając kierowanie przerwań do konkretnych rdzeni CPU."
        },
        {
            "id": 717,
            "questionText": "Czym charakteryzuje się 'przerwanie szybkie' (fast interrupt)?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "szybkie", "wolne"],
            "options": [
                "Jest obsługiwane z odblokowanymi przerwaniami i może zostać przerwane przez inne.",
                "Jest obsługiwane z zablokowanymi przerwaniami i nie może zostać przerwane przez inne.",
                "Po jego obsłudze zawsze uruchamiany jest planista.",
                "Jest używane głównie do obsługi przerwania zegarowego."
            ],
            "correctAnswers": [1],
            "explanation": "Przerwania szybkie są przeznaczone do obsługi bardzo krótkich, krytycznych zdarzeń (np. z karty sieciowej). Aby zminimalizować opóźnienia, są one obsługiwane przy zablokowanych innych przerwaniach."
        },
        {
            "id": 718,
            "questionText": "Jaka jest główna różnica w obsłudze między przerwaniem wolnym a szybkim?",
            "image": "",
            "type": "open-ended",
            "tags": ["przerwania", "sprzętowe", "szybkie", "wolne"],
            "gradingCriteria": "Odpowiedź musi wskazywać, że główna różnica polega na stanie blokady przerwań podczas obsługi. Przerwania szybkie są obsługiwane przy zablokowanych innych przerwaniach, a wolne przy odblokowanych. Dodatkowo można wspomnieć, że po obsłudze przerwania wolnego mogą być wykonywane dodatkowe czynności (np. dolne połówki), czego unika się przy przerwaniach szybkich. Pełna punktacja za wskazanie różnicy w blokadzie.",
            "maxPoints": 5
        },
        {
            "id": 719,
            "questionText": "Która funkcja jądra służy do zarejestrowania procedury obsługi przerwania sprzętowego?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "api"],
            "options": [
                "register_irq()",
                "request_irq()",
                "create_irq()",
                "setup_irq()"
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja `request_irq()` służy do powiązania numeru przerwania (IRQ) z konkretną funkcją obsługi (handlerem) oraz do zdefiniowania właściwości tej obsługi."
        },
        {
            "id": 720,
            "questionText": "Jakiej funkcji należy użyć, aby zwolnić (wyrejestrować) linię przerwania, która nie jest już potrzebna?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "api"],
            "options": [
                "free_irq()",
                "release_irq()",
                "delete_irq()",
                "unregister_irq()"
            ],
            "correctAnswers": [0],
            "explanation": "Do zwolnienia linii przerwania i odłączenia od niej procedury obsługi służy funkcja `free_irq()`, która jest odpowiednikiem `request_irq()`."
        },
        {
            "id": 721,
            "questionText": "Jakie parametry zazwyczaj przyjmuje funkcja obsługi przerwania (handler)?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["przerwania", "sprzętowe", "api", "handler"],
            "options": [
                "irq (numer przerwania)",
                "dev_id (wskaźnik do danych urządzenia)",
                "pt_regs (wskaźnik na rejestry przerwanego procesu)",
                "timestamp (znacznik czasu wystąpienia przerwania)"
            ],
            "correctAnswers": [0, 1, 2],
            "explanation": "Standardowy handler przerwania otrzymuje numer linii IRQ, która je wywołała, wskaźnik do danych urządzenia (przydatny przy dzielonych przerwaniach) oraz wskaźnik na zapisany kontekst (rejestry) przerwanego zadania."
        },
        {
            "id": 722,
            "questionText": "Opisz w punktach algorytm obsługi przerwania wolnego.",
            "image": "",
            "type": "open-ended",
            "tags": ["przerwania", "sprzętowe", "wolne", "algorytm"],
            "gradingCriteria": "Odpowiedź musi zawierać kluczowe kroki w poprawnej kolejności: 1. Zablokowanie przerwań. 2. Zapisanie kontekstu. 3. Odblokowanie przerwań. 4. Wywołanie procedury obsługi. 5. Ponowne zablokowanie przerwań. 6. Ewentualne wykonanie dodatkowych czynności (dolne połówki). Pełna punktacja za wymienienie co najmniej 4 poprawnych kroków w logicznej sekwencji.",
            "maxPoints": 6
        },
        {
            "id": 723,
            "questionText": "Jaka jest kluczowa różnica w algorytmie obsługi przerwania szybkiego w porównaniu do wolnego?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "szybkie", "algorytm"],
            "options": [
                "Nie zapisuje żadnych rejestrów na stosie.",
                "Procedura obsługi jest wywoływana przed zablokowaniem przerwania.",
                "System nie odblokowuje przerwań na czas działania właściwej procedury obsługi.",
                "Zapisuje na stosie tylko część rejestrów i po obsłudze nie wykonuje dodatkowych czynności, takich jak uruchomienie planisty."
            ],
            "correctAnswers": [3],
            "explanation": "W algorytmie obsługi przerwania szybkiego optymalizuje się czas przez zapisanie tylko niezbędnych rejestrów. Co ważniejsze, po zakończeniu obsługi od razu wraca się do przerwanego kodu, pomijając dodatkowe, czasochłonne zadania jak dolne połówki."
        },
        {
            "id": 724,
            "questionText": "Na czym polega mechanizm górnych i dolnych połówek (top and bottom halves) w obsłudze przerwań?",
            "image": "",
            "type": "open-ended",
            "tags": ["przerwania", "dolne połówki", "górne połówki"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że jest to technika podziału obsługi przerwania na dwie części. 1. Górna połówka (top half): wykonywana natychmiast, w kontekście przerwania, bardzo krótka, wykonuje tylko absolutnie krytyczne czynności (np. potwierdzenie odbioru przerwania). 2. Dolna połówka (bottom half): wykonuje resztę pracy (np. przetwarzanie danych), która może być odroczona i uruchomiona później, już w normalnym kontekście, z odblokowanymi przerwaniami. Pełna punktacja za opisanie obu części i celu mechanizmu (skrócenie czasu blokady systemu).",
            "maxPoints": 8
        },
        {
            "id": 725,
            "questionText": "Które dwa sygnały są uważane za 'niezawodne', co oznacza, że proces nie może ich zignorować, zablokować ani przechwycić?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "niezawodne", "sigkill", "sigstop"],
            "options": [
                "SIGINT i SIGTERM",
                "SIGKILL i SIGSTOP",
                "SIGCONT i SIGCHLD",
                "SIGHUP i SIGQUIT"
            ],
            "correctAnswers": [1],
            "explanation": "SIGKILL i SIGSTOP to dwa specjalne sygnały, które nie mogą być obsłużone ani zignorowane przez proces. Zawsze wykonują swoją domyślną akcję (odpowiednio, natychmiastowe zakończenie i zatrzymanie), co gwarantuje administratorowi możliwość kontroli nad każdym procesem."
        },
        {
            "id": 726,
            "questionText": "Czym, w kontekście sygnałów, jest plik 'core' (core dumped) i który sygnał domyślnie powoduje jego utworzenie?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "core dump", "debugowanie", "sigquit"],
            "options": [
                "Jest to plik z kodem źródłowym procesu; tworzy go SIGSRC.",
                "Jest to zrzut pamięci procesu w momencie błędu, służący do debugowania; tworzy go SIGQUIT.",
                "Jest to plik konfiguracyjny jądra; tworzy go SIGCONF.",
                "Jest to plik logu sygnałów; tworzy go SIGLOG."
            ],
            "correctAnswers": [1],
            "explanation": "Plik 'core' to zrzut pamięci procesu, który pozwala na pośmiertną analizę (post-mortem debugging) stanu aplikacji w momencie awarii. Sygnał SIGQUIT jest często używany do manualnego wygenerowania takiego zrzutu."
        },
        {
            "id": 727,
            "questionText": "Jaka jest podstawowa różnica w działaniu między nowoczesną funkcją sigaction() a starszą, klasyczną funkcją signal()?",
            "image": "",
            "type": "single-choice",
            "tags": ["sygnały", "sigaction", "signal", "programowanie"],
            "options": [
                "Nie ma różnicy, to są aliasy.",
                "signal() pozwala na blokowanie sygnałów, a sigaction() nie.",
                "signal() ma niestandardowe, zależne od systemu zachowanie, a sigaction() jest przenośnym standardem POSIX. Dodatkowo, obsługa w signal() często była jednorazowa.",
                "sigaction() jest prostsza w użyciu, ale mniej funkcjonalna."
            ],
            "correctAnswers": [2],
            "explanation": "Główną wadą historycznej funkcji signal() była jej nieprzewidywalność między różnymi systemami UNIX i fakt, że w wielu implementacjach po obsłużeniu sygnału przywracana była akcja domyślna. sigaction() jest standardem POSIX, oferuje znacznie większą kontrolę i przewidywalne, stałe działanie."
        },
        {
            "id": 728,
            "questionText": "Co odróżnia przerwania maskowalne od niemaskowalnych?",
            "image": "",
            "type": "single-choice",
            "tags": ["przerwania", "sprzętowe", "maskowalne", "niemaskowalne"],
            "options": [
                "Przerwania maskowalne pochodzą od oprogramowania, a niemaskowalne od sprzętu.",
                "Przerwania maskowalne mogą być tymczasowo ignorowane (blokowane) przez procesor, a niemaskowalne muszą być obsłużone natychmiast.",
                "Przerwania niemaskowalne mają niższy priorytet.",
                "Przerwania niemaskowalne można obsługiwać za pomocą sygnałów, a maskowalnych nie."
            ],
            "correctAnswers": [1],
            "explanation": "Procesor ma możliwość tymczasowego wyłączenia obsługi przerwań maskowalnych, co jest kluczowe podczas wykonywania krytycznych sekcji kodu. Przerwania niemaskowalne (NMI - Non-Maskable Interrupt) są zarezerwowane dla krytycznych błędów sprzętowych (np. błąd pamięci) i nie mogą być zablokowane."
        }
    ]
}
