{
    "category": "Systemy Operacyjne 2",
    "scope": "Wykład 3: Szeregowanie i wątki w jądrze Linux",
    "version": "1.2",
    "questions": [
        {
            "id": 601,
            "questionText": "Na czym polega szeregowanie procesów w systemie operacyjnym?",
            "image": "",
            "type": "open-ended",
            "tags": ["szeregowanie", "procesy", "planista"],
            "gradingCriteria": "Odpowiedź musi wyjaśniać, że szeregowanie to proces wyboru jednego procesu spośród procesów gotowych do wykonania (w stanie TASK_RUNNING) w celu przydzielenia mu czasu procesora. Celem jest efektywne zarządzanie zasobami CPU. Pełna punktacja za wskazanie celu (wybór procesu) i warunku (stan gotowości).",
            "maxPoints": 5
        },
        {
            "id": 602,
            "questionText": "Jaki jest główny cel funkcji sched_setscheduler()?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "sched_setscheduler", "programowanie"],
            "options": [
                "Zatrzymanie wykonywania określonego procesu.",
                "Ustawienie polityki szeregowania i priorytetu dla danego procesu.",
                "Pobranie aktualnej polityki szeregowania procesu.",
                "Oddanie przez proces reszty swojego kwantu czasu."
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja ta pozwala na dynamiczną zmianę zarówno algorytmu (polityki) szeregowania, jak i priorytetu dla procesu o określonym PID."
        },
        {
            "id": 603,
            "questionText": "Która klasa szeregowania realizuje prostą politykę 'pierwszy wszedł, pierwszy wyszedł' bez przydziału kwantów czasu?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "fifo"],
            "options": [
                "SCHED_RR",
                "SCHED_NORMAL",
                "SCHED_FIFO",
                "SCHED_IDLE"
            ],
            "correctAnswers": [2],
            "explanation": "SCHED_FIFO (First-In, First-Out) to polityka czasu rzeczywistego, w której proces działa aż do zablokowania, dobrowolnego oddania procesora, lub wywłaszczenia przez proces o wyższym priorytecie. Nie używa kwantów czasu."
        },
        {
            "id": 604,
            "questionText": "Czym charakteryzuje się klasa szeregowania SCHED_RR?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "round-robin"],
            "options": [
                "Jest przeznaczona dla zadań działających w tle, gdy system nie ma nic innego do roboty.",
                "Jest to polityka 'każdy z każdym po trochu', gdzie procesy o tym samym priorytecie otrzymują cyklicznie kwanty czasu procesora.",
                "Gwarantuje ona wykonanie zadania przed upływem określonego terminu (deadline).",
                "Jest to domyślna polityka dla zwykłych procesów, oparta na sprawiedliwym podziale czasu."
            ],
            "correctAnswers": [1],
            "explanation": "SCHED_RR (Round Robin) to polityka czasu rzeczywistego podobna do FIFO, ale z dodatkowym mechanizmem kwantów czasu. Jeśli proces nie zakończy się przed upływem swojego kwantu, jest przenoszony na koniec kolejki procesów o tym samym priorytecie."
        },
        {
            "id": 605,
            "questionText": "Jaka jest domyślna klasa szeregowania dla standardowych, interaktywnych procesów użytkownika w nowoczesnych systemach Linux?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "cfs", "normal"],
            "options": [
                "SCHED_OTHER",
                "SCHED_BATCH",
                "SCHED_DEADLINE",
                "SCHED_NORMAL"
            ],
            "correctAnswers": [3],
            "explanation": "SCHED_NORMAL jest standardową polityką szeregowania używaną przez planistę CFS. Zastąpiła ona starszą politykę SCHED_OTHER i jest przeznaczona dla wszystkich procesów, które nie wymagają specjalnego traktowania (np. czasu rzeczywistego)."
        },
        {
            "id": 606,
            "questionText": "Dla jakiego typu zadań przeznaczona jest klasa szeregowania SCHED_BATCH?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "batch"],
            "options": [
                "Dla zadań krytycznych czasowo, które muszą być wykonane natychmiast.",
                "Dla zadań interaktywnych, wymagających szybkiej odpowiedzi od systemu.",
                "Dla zadań intensywnie wykorzystujących CPU, ale nie interaktywnych (np. kompilacja, obliczenia naukowe), które mogą być karane na rzecz zadań interaktywnych.",
                "Dla zadań o najniższym możliwym priorytecie, wykonywanych tylko gdy CPU jest bezczynny."
            ],
            "correctAnswers": [2],
            "explanation": "SCHED_BATCH (szeregowanie wsadowe) jest zoptymalizowane dla zadań 'pożerających' CPU. Planista zakłada, że nie są one interaktywne i może rzadziej je przełączać, co poprawia wykorzystanie pamięci podręcznej, ale kosztem responsywności."
        },
        {
            "id": 607,
            "questionText": "Która klasa szeregowania przypisuje procesowi najniższy możliwy priorytet, aby był on wykonywany tylko wtedy, gdy system nie ma absolutnie nic innego do zrobienia?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "idle"],
            "options": [
                "SCHED_FIFO",
                "SCHED_IDLE",
                "SCHED_BATCH",
                "SCHED_NORMAL"
            ],
            "correctAnswers": [1],
            "explanation": "SCHED_IDLE jest przeznaczona dla zadań o ekstremalnie niskim priorytecie. Zapewnia, że procesy w tej klasie nie będą zakłócać pracy żadnych innych, nawet zadań typu BATCH."
        },
        {
            "id": 608,
            "questionText": "Jaki jest cel klasy szeregowania SCHED_DEADLINE?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "klasy", "deadline"],
            "options": [
                "Zapewnienie, że proces otrzyma określony czas CPU w danym okresie, co jest kluczowe dla systemów czasu rzeczywistego (np. streaming wideo).",
                "Uruchomienie procesu po upływie określonego czasu.",
                "Automatyczne zakończenie procesu, jeśli przekroczy on swój termin.",
                "Sprawiedliwy podział czasu CPU między wszystkie procesy w systemie."
            ],
            "correctAnswers": [0],
            "explanation": "SCHED_DEADLINE to najbardziej zaawansowana polityka czasu rzeczywistego, gdzie zadanie określa swoje wymagania (runtime, period, deadline). Planista gwarantuje, że zadanie otrzyma `runtime` czasu CPU w każdym `period`, nie przekraczając `deadline`."
        },
        {
            "id": 609,
            "questionText": "Które z poniższych pól w strukturze `task_struct` są bezpośrednio związane z priorytetami i szeregowaniem procesu?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["szeregowanie", "priorytet", "task_struct"],
            "options": [
                "pid",
                "rt_priority",
                "policy",
                "counter"
            ],
            "correctAnswers": [1, 2, 3],
            "explanation": "Pola `rt_priority` (priorytet czasu rzeczywistego), `policy` (klasa szeregowania) i `counter` (w starszych kernelach, reprezentujący kwant czasu) są kluczowe dla podejmowania decyzji przez planistę."
        },
        {
            "id": 610,
            "questionText": "Co robi funkcja `sched_yield()`?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "sched_yield", "programowanie"],
            "options": [
                "Zmienia priorytet bieżącego procesu na najwyższy.",
                "Zatrzymuje wykonanie procesu na stały okres czasu.",
                "Powoduje, że bieżący proces dobrowolnie oddaje procesor, pozwalając planiście wybrać inny proces do wykonania.",
                "Zwraca aktualną politykę szeregowania dla bieżącego procesu."
            ],
            "correctAnswers": [2],
            "explanation": "Wywołanie `sched_yield()` to sposób, w jaki proces może poinformować planistę, że jest gotów oddać resztę swojego kwantu czasu, aby umożliwić działanie innym procesom."
        },
        {
            "id": 611,
            "questionText": "Zgodnie z jakimi kryteriami ustalana jest kolejność wykonywania procesów?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["szeregowanie", "priorytet", "kolejność"],
            "options": [
                "Według klasy szeregowania (np. procesy czasu rzeczywistego przed zwykłymi).",
                "Według wartości priorytetu w ramach danej klasy.",
                "Według kolejności przybycia do kolejki procesów gotowych (przy tych samych priorytetach).",
                "Według rozmiaru procesu w pamięci."
            ],
            "correctAnswers": [0, 1, 2],
            "explanation": "Planista najpierw bierze pod uwagę klasę szeregowania, następnie priorytet wewnątrz tej klasy, a na końcu (np. w SCHED_FIFO) kolejność na liście gotowych procesów."
        },
        {
            "id": 612,
            "questionText": "Jaki jest zakres priorytetów czasu rzeczywistego (`rt_priority`)?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "priorytet", "rt_priority"],
            "options": [
                "od 0 do 100",
                "od 1 do 99",
                "od -20 do 19",
                "od 1 do 255"
            ],
            "correctAnswers": [1],
            "explanation": "Priorytety czasu rzeczywistego w Linuksie przyjmują wartości od 1 (najniższy) do 99 (najwyższy). Wartość 0 oznacza, że proces nie jest procesem czasu rzeczywistego."
        },
        {
            "id": 613,
            "questionText": "Czym jest planista CFS (Completely Fair Scheduler)?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "cfs", "planista"],
            "options": [
                "Planistą przeznaczonym wyłącznie do obsługi żądań wejścia/wyjścia.",
                "Starszym planistą używanym w pierwszych wersjach jądra Linux.",
                "Nowoczesnym planistą procesów w Linuksie, który ma za zadanie sprawiedliwie dzielić czas procesora między wszystkie zadania.",
                "Planistą używanym tylko w systemach wbudowanych o architekturze ARM."
            ],
            "correctAnswers": [2],
            "explanation": "CFS to domyślny planista w jądrze Linux, który implementuje politykę SCHED_NORMAL, starając się zapewnić każdemu procesowi 'sprawiedliwy' udział w czasie CPU."
        },
        {
            "id": 614,
            "questionText": "Ile głównych typów planistów (schedulerów) funkcjonuje w systemie Linux?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "planista", "cfs", "io"],
            "options": [
                "Jeden - uniwersalny planista do wszystkiego.",
                "Dwa - planista procesów (np. CFS) i planista wejścia/wyjścia.",
                "Trzy - planista dla procesów, planista dla wątków i planista dla I/O.",
                "Cztery - po jednym dla każdej głównej klasy szeregowania."
            ],
            "correctAnswers": [1],
            "explanation": "System Linux posiada oddzielne mechanizmy planowania dla dostępu do CPU (planista procesów, np. CFS) oraz dla dostępu do urządzeń blokowych (planista wejścia/wyjścia)."
        },
        {
            "id": 615,
            "questionText": "Jak działa planista CFS?",
            "image": "",
            "type": "open-ended",
            "tags": ["szeregowanie", "cfs", "planista"],
            "gradingCriteria": "Odpowiedź musi zawierać kluczową zasadę działania CFS: planista stara się dać pierwszeństwo procesowi, który do tej pory wykorzystał najmniej czasu procesora. Czas ten jest śledzony za pomocą wirtualnego zegara dla każdego procesu. Pełna punktacja za wyjaśnienie koncepcji 'najmniej obsłużonego' procesu.",
            "maxPoints": 5
        },
        {
            "id": 616,
            "questionText": "Które z poniższych są typami planistów wejścia/wyjścia dla trybu z jedną kolejką?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["szeregowanie", "planista", "io"],
            "options": [
                "deadline",
                "kyber",
                "CFQ (Complete Fair Queuing)",
                "noop"
            ],
            "correctAnswers": [0, 2, 3],
            "explanation": "Dla trybu non-multiqueue I/O dostępne są planiści: deadline (terminowy), CFQ (sprawiedliwej kolejki) oraz noop (najprostszy, bez sortowania)."
        },
        {
            "id": 618,
            "questionText": "Czym wątek jądra różni się od standardowego procesu użytkownika?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "procesy"],
            "options": [
                "Nie podlega mechanizmom szeregowania.",
                "Nie posiada własnej, wydzielonej przestrzeni adresowej - korzysta z przestrzeni adresowej jądra.",
                "Nie może być wyświetlony za pomocą polecenia `ps`.",
                "Nie może tworzyć innych wątków ani procesów."
            ],
            "correctAnswers": [1],
            "explanation": "Kluczową różnicą jest to, że wątki jądra wykonują się w przestrzeni jądra i dzielą jego przestrzeń adresową, podczas gdy procesy użytkownika mają własne, izolowane przestrzenie adresowe."
        },
        {
            "id": 619,
            "questionText": "Jaki jest format deklaracji funkcji, która ma być wykonywana jako wątek jądra?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie"],
            "options": [
                "void moja_funkcja(void)",
                "int moja_funkcja(void *dane)",
                "void* moja_funkcja(int dane)",
                "kthread_func moja_funkcja(void)"
            ],
            "correctAnswers": [1],
            "explanation": "Funkcja przeznaczona na wątek jądra musi przyjmować jeden argument typu `void*` (wskaźnik na dowolne dane) i zwracać wartość `int`."
        },
        {
            "id": 620,
            "questionText": "Która funkcja służy wyłącznie do utworzenia nowego wątku jądra (bez jego uruchamiania)?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie", "kthread_create"],
            "options": [
                "kthread_run",
                "kthread_start",
                "kthread_create",
                "kthread_init"
            ],
            "correctAnswers": [2],
            "explanation": "Funkcja `kthread_create` tworzy wątek i przygotowuje go do uruchomienia, ale pozostawia go w stanie zatrzymanym. Zwraca wskaźnik do struktury `task_struct` nowego wątku."
        },
        {
            "id": 621,
            "questionText": "Jak można rozpoznać wątki jądra na liście procesów wyświetlanej przez polecenie `ps`?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "polecenia", "ps"],
            "options": [
                "Mają PID mniejszy od 10.",
                "Są oznaczone gwiazdką (*) na końcu nazwy.",
                "Ich nazwy są ujęte w nawiasy kwadratowe.",
                "Są wyświetlane w oddzielnej sekcji na końcu listy."
            ],
            "correctAnswers": [2],
            "explanation": "Standardową konwencją jest, że nazwy wątków jądra, takie jak `[kworker/0:1]` czy `[ksoftirqd/0]`, są pokazywane w nawiasach kwadratowych."
        },
        {
            "id": 622,
            "questionText": "Jaki plik nagłówkowy jest wymagany do tworzenia i zarządzania wątkami jądra?",
            "image": "/static/jakinaglowek.png",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie", "nagłówki"],
            "options": [
                "#include <linux/thread.h>",
                "#include <linux/sched.h>",
                "#include <linux/kthread.h>",
                "#include <linux/module.h>"
            ],
            "correctAnswers": [2],
            "explanation": "Wszystkie funkcje związane z wątkami jądra, takie jak `kthread_create`, `kthread_stop` czy `kthread_run`, są zdefiniowane w pliku `<linux/kthread.h>`."
        },
        {
            "id": 623,
            "questionText": "Która funkcja służy do zatrzymania wątku jądra i jaki warunek musi być spełniony w pętli głównej wątku, aby to było możliwe?",
            "image": "",
            "type": "open-ended",
            "tags": ["wątki", "jądro", "programowanie", "kthread_stop"],
            "gradingCriteria": "Odpowiedź musi zawierać dwie części: 1. Nazwa funkcji: `kthread_stop()`. 2. Warunek: pętla główna wątku musi cyklicznie sprawdzać wynik funkcji `kthread_should_stop()`. Pełna punktacja za podanie obu elementów.",
            "maxPoints": 5
        },
        {
            "id": 624,
            "questionText": "Które z poniższych stwierdzeń są prawdziwe?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["wątki", "jądro", "programowanie", "kthread_run", "wake_up_process"],
            "options": [
                "`kthread_create` tworzy i natychmiast uruchamia wątek.",
                "`wake_up_process` służy do uruchomienia wątku, który został wcześniej utworzony za pomocą `kthread_create`.",
                "`kthread_run` to makro, które łączy w sobie utworzenie i uruchomienie wątku.",
                "`kthread_stop` natychmiastowo przerywa działanie wątku, niezależnie od tego co robi."
            ],
            "correctAnswers": [1, 2],
            "explanation": "`wake_up_process` 'budzi' nowo utworzony, zatrzymany wątek. `kthread_run` jest wygodnym makrem, które wykonuje operacje `kthread_create`, a następnie `wake_up_process`."
        },
        {
            "id": 625,
            "questionText": "Co robi makro `kthread_run`?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie", "kthread_run"],
            "options": [
                "Tylko tworzy wątek, ale go nie uruchamia.",
                "Tylko uruchamia istniejący wątek.",
                "Tworzy nowy wątek i od razu go uruchamia.",
                "Kompiluje kod wątku i ładuje go do jądra."
            ],
            "correctAnswers": [2],
            "explanation": "`kthread_run` jest makrem, które stanowi wygodny skrót dla wykonania po sobie `kthread_create` i `wake_up_process`."
        },
        {
            "id": 626,
            "questionText": "Jaki mechanizm jest najczęściej używany do usypiania i wznawiania pracy wątku, który czeka na jakieś zdarzenie?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie", "waitqueue"],
            "options": [
                "Użycie pętli z funkcją `ssleep()`.",
                "Użycie zmiennej globalnej i aktywne jej sprawdzanie w pętli.",
                "Użycie kolejki oczekiwania (wait queue), którą inicjuje się za pomocą `init_waitqueue_head()`.",
                "Użycie funkcji `kthread_pause()` i `kthread_resume()`."
            ],
            "correctAnswers": [2],
            "explanation": "Kolejki oczekiwania (wait queues) to standardowy i wydajny mechanizm w jądrze Linux do usypiania wątków, które na coś czekają, i budzenia ich, gdy zdarzenie nastąpi."
        },
        {
            "id": 627,
            "questionText": "Która funkcja pozwala na uśpienie bieżącego wątku na określoną liczbę sekund?",
            "image": "",
            "type": "single-choice",
            "tags": ["wątki", "jądro", "programowanie", "sleep"],
            "options": [
                "msleep()",
                "usleep()",
                "kthread_sleep()",
                "ssleep()"
            ],
            "correctAnswers": [3],
            "explanation": "Funkcja `ssleep()`, zdefiniowana w `<linux/delay.h>`, służy do uśpienia wątku na liczbę sekund podaną jako argument."
        },
        {
            "id": 628,
            "questionText": "Które z poniższych są poprawnymi parametrami funkcji sched_setscheduler()?",
            "image": "",
            "type": "multiple-choice",
            "tags": ["szeregowanie", "sched_setscheduler", "programowanie"],
            "options": [
                "pid (identyfikator procesu)",
                "policy (polityka szeregowania)",
                "param (wskaźnik na strukturę z priorytetem)",
                "new_name (nowa nazwa procesu)"
            ],
            "correctAnswers": [0, 1, 2],
            "explanation": "Sygnatura funkcji to `int sched_setscheduler(pid_t pid, int policy, struct sched_param *param)`, wymaga ona podania PID procesu, nowej polityki oraz wskaźnika do struktury z parametrami, w tym priorytetem."
        },
        {
            "id": 629,
            "questionText": "Co określa parametr `policy` w funkcji sched_setscheduler()?",
            "image": "",
            "type": "single-choice",
            "tags": ["szeregowanie", "sched_setscheduler", "programowanie"],
            "options": [
                "Nowy priorytet numeryczny procesu.",
                "Identyfikator procesu, którego dotyczy zmiana.",
                "Algorytm szeregowania, który ma być zastosowany (np. SCHED_FIFO, SCHED_RR).",
                "Maksymalny czas, przez jaki proces może działać."
            ],
            "correctAnswers": [2],
            "explanation": "Parametr `policy` służy do wyboru jednej z dostępnych klas szeregowania, takich jak SCHED_FIFO, SCHED_RR, SCHED_NORMAL itp."
        }
    ]
}
